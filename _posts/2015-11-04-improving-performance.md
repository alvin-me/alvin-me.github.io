---
layout: post
title: "8.1 提高性能"
tagline: ""
category : doc
tags : ["体绘制"]
---

GPU体绘制算法的性能通常与片段处理器`fragment`有关。更大的数据，更高的采样率和图像分辨率，这些都需要更多的片段处理来准确地表示数据。伴随着大量的片段，内存带宽和延迟变得越来越重要，这是因为每个片段都要读入体数据`volume`中的部分值。由于内存带宽和延迟强烈依赖于所使用的内存访问模式，我们必须在渲染时以最优方式访问体数据。

除了内存访问瓶颈外，包含了大量的ALU指令运算的片段程序是另一个主要瓶颈。因此，必须减少包含复杂片段着色器程序的执行数。一种方法是使用“昂贵的”计算，选择性地访问内存。此外，诸如空间跳跃，跳过遮挡部分，和光线提前终止等方法都有利于提高性能。

## 一、提高内存访问

虽然今天的GPU已经提供了每秒超过30GB的巨大峰值带宽，大数据的可视化仍需要采用优化技术以达到满意的帧率。

试想一下一个1GB的体数据：理论上30GB每秒的内存带宽可以提供足够的带宽来访问整个体数据每秒30次；忽略掉渲染时间，应该得到30帧每秒的帧率。然后在实践中，会有多方面的原因影响到该计算：

* 一次三线性插值需要从体数据中访问它周边的八个顶点。体数据大多数值需要被多次读入，因为相邻的片段可能需要相同的数据值来计算三线性插值。GPU内部的纹理缓存机制试图解决这个问题，通过读入之前的纹理获取值来提供快速访问数据值。但是这并不能完全防止数据的多次访问。
* 一些算法需要多个插值数据来计算每个片段的结果。例如，高质量的滤波就需要多个体素`voxel`。此外，实时着色运算也需要获取相邻的体素来计算局部梯度。
* GPU内存带宽理论值只存在于纹理访问完全以一种纹理缓存友好的方式。这在大多数情况下都不适用，尤其是使用三维纹理，或者是使用上一次的纹理查找结果做为下一次纹理查找坐标的情况下(关联纹理查找)。因此，实际持续带宽通常是远远低于我们所预期的。

除了内存带宽的限制，人们往往会低估内存延迟所带来的问题。内存延迟是指在访问内存时请求与发送数据的时间间隔。因为GPU被设计为流处理器`streaming processors`，包括一个优化的内存控制单元，内存延迟可以在顺序读写数据时被隐藏掉。将内存访问和数学指令运算并行是另一种隐藏内存延迟的有效的方法。着色器语言编译器或GPU驱动通常会自动进行这类优化。

尽管有以上这些优化，图像顺序`image-order`的算法例如光线投射，请求非相干的内存访问模式极大的降低了内存子系统的性能。即使是对象顺序`object-order`的渲染算法也会依赖于当前视线方向的帧率。对于某些图形卡，三维纹理切片方法`texture-based slicing`的性能相对于其他视线方向，在沿着Z方向是最快的。这是因为纹理缓存效率的不一致性。假设我们实现了一个对象顺序的体绘制算法，首先沿着X方向访问体数据(如图1左)，然后是Y方向，最后是Z方向。因为数据是以线性的方式读取，内存控制器和纹理缓存都非常有效的执行。每次读取内存，一定数量的连续数值会被读入缓冲池。如果新读取数据地址非常接近之前读入的数据，则该数据有很大的概率已经存在高速缓冲池中。基于切片的体绘制方法，在Z方向的内存访问模式和上述描述的场景很相似。

然而，如果我们首先在Z方向上访问体数据，其次Y方向，最后X方向，我们将会以非线性方式访问数据，实际上我们在内存中跳来跳去。这种访问方式不利于内存控制和纹理缓存，大大降低了性能。如果切片体绘制的代理几何体`proxy geometry`是位于垂直于X或Y方向，内存访问方式就和这类所述场景很相似。由于内存控制和纹理缓存使用的不一致性，我们将根据视线方向的不同得到明显差异的渲染性能(如图2)。

<div class="illustration">
	<img src="{{ BASE_PATH }}/images/linear-swizzled-volume.jpg" width="80%"/>
	<div class="text"><p>Fig.1 线性内存布局(左)，相邻体素间的距离和轴向相关，绞合(swizzled)内存布局基于块元素(右)，具有更稳定均衡的距离。</p></div>
</div>

<div class="illustration">
	<img src="{{ BASE_PATH }}/images/performance-swizzled-unswizzled.png" width="80%"/>
	<div class="text"><p>Fig.2 沿着三个轴方向实时计算梯度，使用绞合纹理和非绞合纹理的性能对比。使用NVIDIA GeForce GT PCIe x16显卡测试。上图是使用绞合纹理，下图是非绞合纹理。需要注意的是绞合纹理在不同视线方向上提供更加均衡的帧率。</p></div>
</div>

#### 1. Mipmapping

如果投影体素大小小于输出图像像素大小，采用mipmapping缩小体数据可以提高渲染性能，减少伪影。MIP是拉丁语`multum in parvo`的缩写，意思是“在很小的空间内”。Mipmaps是对原始数据预先滤波处理得到的较小的数据。每一层mipmap包含的数据是下一较低层mipmap一半的分辨率。二维mipmaps增加约1/3的数据存储量，三维mipmaps需要约1/7的额外内存。

GPU支持1D，2D，3D mipmapping纹理，可以存储多层mipmap并在渲染过程中根据缩放参数自动选择合适层的mipmap进行插值。由于mipmaps的尺寸较小，并且较低分辨率层mipmap的体素相邻较近，纹理缓存变得更加高效。因此，mipmaping可以显著地提升渲染性能。

用户在观察科学数据时有时会关注隐藏在数据中的小细节，在各种应用中需要对体数据进行放大。因此，在渲染时仍需要用到全分辨率的体数据，这时，mipmapping无法提升渲染性能。

#### 2. 块级绞合(Block-Based Swizzling)

为了规避这个问题，一种解决方法是将体数据存储为以块级形式绞合的方式，如图1右。这种体素排列方式通常称为绞合`swizzling`。块级方式绞合在概念上等同于`bricking`。注意图1中使用块级大小 2^3 仅为了澄清问题。较大的块如 32^3 可能更有效。需要注意的是，在相邻的块之间我们需要至少一个像素的重叠来保证连续插值。块越小，所需要重叠的区域占用内存越大。

使用块级方法可以增加相邻体素的位置相关性。如果我们访问同一块级内的数据，数据寻址时间要远小于寻址线性内存分布的时间。再次，请记住局部内存访问增加缓存命中率。blocks/bricks是一个一个线性排列的。然而位于不同的块级元素的体素寻址仍然距离很大，实际上我们并不需要跨越blocks进行数据访问，所有的内存跨blocks级的访问都可以通过使用blocks的重叠来达到目标。

<br/>
翻译自 "[Real-Time Volume Graphics](http://www.real-time-volume-graphics.org/)" 8.1小节。