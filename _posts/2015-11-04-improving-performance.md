---
layout: post
title: "提高性能"
tagline: ""
category : doc
tags : ["体绘制"]
---

GPU体绘制算法的性能通常与片段处理器`fragment`有关。更大的数据，更高的采样率和图像分辨率，这些都需要更多的片段处理来准确地表示数据。伴随着大量的片段，内存带宽和延迟变得越来越重要，这是因为每个片段都要读入体数据`volume`中的部分值。由于内存带宽和延迟强烈依赖于所使用的内存访问模式，我们必须在渲染时以最优方式访问体数据。

除了内存访问瓶颈外，包含了大量的ALU指令运算的片段程序是另一个主要瓶颈。因此，必须减少包含复杂片段着色器程序的执行数。一种方法是使用“昂贵的”计算，选择性地访问内存。此外，诸如空间跳跃，跳过遮挡部分，和光线提前终止等方法都有利于提高性能。

## 一、提高内存访问

虽然今天的GPU已经提供了每秒超过30GB的巨大峰值带宽，大数据的可视化仍需要采用优化技术以达到满意的帧率。

试想一下一个1GB的体数据：理论上30GB每秒的内存带宽可以提供足够的带宽来访问整个体数据每秒30次；忽略掉渲染时间，应该得到30帧每秒的帧率。然后在实践中，会有多方面的原因影响到该计算：

* 一次三线性插值需要从体数据中访问它周边的八个顶点。体数据大多数值需要被多次读入，因为相邻的片段可能需要相同的数据值来计算三线性插值。GPU内部的纹理缓存机制试图解决这个问题，通过读入之前的纹理获取值来提供快速访问数据值。但是这并不能完全防止数据的多次访问。
* 一些算法需要多个插值数据来计算每个片段的结果。例如，高质量的滤波就需要多个体素`voxel`。此外，实时着色运算也需要获取相邻的体素来计算局部梯度。
* GPU内存带宽理论值只存在于纹理访问完全以一种纹理缓存友好的方式。这在大多数情况下都不适用，尤其是使用三维纹理，或者是使用上一次的纹理查找结果做为下一次纹理查找坐标的情况下(关联纹理查找)。因此，实际持续带宽通常是远远低于我们所预期的。

除了内存带宽的限制，人们往往会低估内存延迟所带来的问题。内存延迟是指在访问内存时请求与发送数据的时间间隔。因为GPU被设计为流处理器`streaming processors`，包括一个优化的内存控制单元，内存延迟可以在顺序读写数据时被隐藏掉。将内存访问和数学指令运算并行是另一种隐藏内存延迟的有效的方法。着色器语言编译器或GPU驱动通常会自动进行这类优化。

尽管有以上这些优化，图像顺序`image-order`的算法例如光线投射，请求非相干的内存访问模式极大的降低了内存子系统的性能。即使是对象顺序`object-order`的渲染算法也会依赖于当前视线方向的帧率。对于某些图形卡，三维纹理切片方法`texture-based slicing`的性能相对于其他视线方向，在沿着Z方向是最快的。这是因为纹理缓存效率的不一致性。假设我们实现了一个对象顺序的体绘制算法，首先沿着X方向访问体数据(如图1左)，然后是Y方向，最后是Z方向。因为数据是以线性的方式读取，内存控制器和纹理缓存都非常有效的执行。每次读取内存，一定数量的连续数值会被读入缓冲池。如果新读取数据地址非常接近之前读入的数据，则该数据有很大的概率已经存在高速缓冲池中。基于切片的体绘制方法，在Z方向的内存访问模式和上述描述的场景很相似。

然而，如果我们首先在Z方向上访问体数据，其次Y方向，最后X方向，我们将会以非线性方式访问数据，实际上我们在内存中跳来跳去。这种访问方式不利于内存控制和纹理缓存，大大降低了性能。如果切片体绘制的代理几何体`proxy geometry`是位于垂直于X或Y方向，内存访问方式就和这类所述场景很相似。由于内存控制和纹理缓存使用的不一致性，我们将根据视线方向的不同得到明显差异的渲染性能(如图2)。

<div class="illustration">
	<img src="{{ BASE_PATH }}/images/linear-swizzled-volume.jpg" width="80%"/>
	<div class="text"><p>Fig.1 线性内存布局(左)，相邻体素间的距离和轴向相关，绞合(swizzled)内存布局基于块元素(右)，具有更稳定均衡的距离。</p></div>
</div>

<div class="illustration">
	<img src="{{ BASE_PATH }}/images/performance-swizzled-unswizzled.png" width="80%"/>
	<div class="text"><p>Fig.2 沿着三个轴方向实时计算梯度，使用绞合纹理和非绞合纹理的性能对比。使用NVIDIA GeForce GT PCIe x16显卡测试。上图是使用绞合纹理，下图是非绞合纹理。需要注意的是绞合纹理在不同视线方向上提供更加均衡的帧率。</p></div>
</div>

#### 1. Mipmapping

如果投影体素大小小于输出图像像素大小，采用mipmapping缩小体数据可以提高渲染性能，减少伪影。MIP是拉丁语`multum in parvo`的缩写，意思是“在很小的空间内”。Mipmaps是对原始数据预先滤波处理得到的较小的数据。每一层mipmap包含的数据是下一较低层mipmap一半的分辨率。二维mipmaps增加约1/3的数据存储量，三维mipmaps需要约1/7的额外内存。

GPU支持1D，2D，3D mipmapping纹理，可以存储多层mipmap并在渲染过程中根据缩放参数自动选择合适层的mipmap进行插值。由于mipmaps的尺寸较小，并且较低分辨率层mipmap的体素相邻较近，纹理缓存变得更加高效。因此，mipmaping可以显著地提升渲染性能。

用户在观察科学数据时有时会关注隐藏在数据中的小细节，在各种应用中需要对体数据进行放大。因此，在渲染时仍需要用到全分辨率的体数据，这时，mipmapping无法提升渲染性能。

#### 2. 块级绞合(Block-Based Swizzling)

为了规避这个问题，一种解决方法是将体数据存储为以块级形式绞合的方式，如图1右。这种体素排列方式通常称为绞合`swizzling`。块级方式绞合在概念上等同于`bricking`。注意图1中使用块级大小 2^3 仅为了澄清问题。较大的块如 32^3 可能更有效。需要注意的是，在相邻的块之间我们需要至少一个像素的重叠来保证连续插值。块越小，所需要重叠的区域占用内存越大。

使用块级方法可以增加相邻体素的位置相关性。如果我们访问同一块级内的数据，数据寻址时间要远小于寻址线性内存分布的时间。再次，请记住局部内存访问增加缓存命中率。blocks/bricks是一个一个线性排列的。然而位于不同的块级元素的体素寻址仍然距离很大，实际上我们并不需要跨越blocks进行数据访问，所有的内存跨blocks级的访问都可以通过使用blocks的重叠来达到目标。

## 二、异步数据上传

异步数据传输允许计算机CPU持续工作的同时传输数据。当CPU启动了数据传输任务后，剩下的传输本身是由<abbr title="direct memory access">DMA</abbr>控制器完成。

如果体数据太大，不能一次性全部存储到GPU显存中，就需要将数据进行分块，在渲染时再将所需要的块数据传输到GPU显存中。为了保证数据上传时的性能，首先要在内存中将块数据准备好，这些块数据是作为一个连续的数据块包含相邻块的重叠，被发送到GPU。

当使用OpenGL命令 `glTexSubImage3D`或`glTexSubImage2D`发送纹理数据到GPU时，CPU通常先将数据复制到<abbr title="accelerated graphics port">AGP</abbr>内存并保持CPU阻塞直到数据被发送到GPU。因此，所有后续OpenGL命令需要在数据传输完成以后才能执行。像素缓冲区对象(PBO)支持使用DMA异步上传数据到GPU，即如果使用异步传输CPU不会被阻塞。然而，数据必须首先已经以GPU内部格式存储在AGP内存中。

如上一节所提到的，一些图形显卡通过重排数据格式来存储三维纹理数据以参加相邻数据的位置相关性。这样做的后果是，CPU在上传数据到GPU前，首先要在内存中重新排列数据。阻止CPU参与到数据上传的方法是在内存中使用GPU内部格式存储数据，然后告诉驱动数据已经准备好。然而目前没有官方OpenGL机制可以实现这种方案。

Non-power-of-two(NPOT)纹理不需要在上传数据到GPU前，重排和拷贝数据。因此，NPOT纹理可以以理论极限带宽值进行异步传输。

需要指出的是，NPOT纹理应该足够小，防止在依赖视线的渲染中，因内存访问缓存导致的渲染性能下降。我们建议使用NPOT纹理分辨率大小接近 $64\times64\times64$, 例如 $64\times64\times63$。

为了达到最佳上传性能，使用OpenGL扩展`ARB_pixel_buffer_object`将纹理数据以异步流 `stream` 形式传入GPU。使用PBOs通过DMA控制器从AGP内存中异步传输数据到GPU显存中。

我们在NVIDIA GeForce 6800 TG PCIe x16上测试使用PBO上传NPOT三纹理数据大约是没有使用PBO传输速度的4倍。注意，在最佳情况下的带宽使用情况仍然远未达到PCIe x16的理论带宽值4GB每秒。这可能是由于NVIDIA板上的AGP/PCIe桥造成的。


## 三、双线性滤波

我们在片元程序中对三维纹理采样，每次三线性插值都需要获取周边8个顶点数据值。因此三维纹理采样是一个非常“昂贵”的操作。一个比较直接的解决办法是使用最近邻插值法来替换。不幸的是，大多数GPU没有为不同的滤波方式实现特定的优化，使用最近邻并不能提升性能。

与三维纹理相比较，二维纹理查找只需要4个顶点来进行双线性插值。因引，二维纹理线性插值相对于三维纹理查找只需要一半的内存带宽。此外由于二维纹理比较小，二维纹理更加容易处理GPU内部纹理缓存。因为GPU主要是被设计来渲染游戏，主要使用二维纹理，GPU对此做了更优的处理。

以我们的经验来看，采用基于二维纹理体绘制的方法帧率快过使用三维纹理50%。但是二维纹理体绘制需要额外的存储三个主轴方向的切片数据，数据量变成三倍。通常，三倍的数据量是不可行的，尤其是考虑到大数据的情况下。另一方面，体绘制经常


































<br/>
翻译自 "[Real-Time Volume Graphics](http://www.real-time-volume-graphics.org/)" 8.1，8.2小节。